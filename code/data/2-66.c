/*
 * 2.66
 *
 * Write code to implement the following function:
 *
 * Generate mask indicating leftmost 1 in x. Assume w = 32.
 * For example, 0xFF00 -> 0x8000, and 0x6600 -> 0x4000.
 * If x = 0, then return 0.
 *
 * int leftmost_one(unsigned x);
 *
 * Must follow the same integer encoding rules:
 *
 * Code must follow the following bit-level integer coding rules:
 *
 * 1. Integers are represented in two's-complement form
 * 2. Right shifts of signed data are performed arithmetically
 * 3. Data type int is "w" bits long. Can use sizeof(int) << 3 to compute w.
 * 4. Conditionals, loops, switch statements, function cals, and macro
 * invocations are forbidden.
 * 5. Division, modulus, and multiplication are forbidden.
 * 6. Relative comparison operators (<, >, <=, >=) are forbidden.
 *
 * !!!!! Code should contain a total of at most 15 arithmetic, bitwise, and 
 * logical operations. !!!!!
 *
 * Hint: First transform x into a bit vector of the form [0 ... 011 ... 1].
*/

#include <stdio.h>
#include <assert.h>

int leftmost_one(unsigned x) {
	// Need to finish
	return 0;
}

// Write main() for testing
